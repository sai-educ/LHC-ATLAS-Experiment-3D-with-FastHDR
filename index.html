<!DOCTYPE html>
<html lang="en">
<head>
    <title>LHC ATLAS Detector - 3D Particle Collision Simulation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }
        
        #container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        
        #info a {
            color: #47a3ff;
            text-decoration: none;
        }
        
        #info a:hover {
            text-decoration: underline;
        }
        
        #detector-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
            z-index: 100;
        }
        
        .layer-info {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .layer-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 8px;
            box-shadow: 0 0 3px rgba(255,255,255,0.3);
        }
        
        #controls {
            position: absolute;
            top: 50px;
            right: 10px;
            z-index: 100;
        }
        
        #collision-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        #collision-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        #collision-button:active {
            transform: translateY(0);
        }
        
        #collision-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #beam-status {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0,0,0,0.8);
            border-radius: 20px;
            font-size: 14px;
            color: #00ff00;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <strong>LHC ATLAS Detector</strong> - 3D Particle Collision Simulation<br/>
        <span style="font-size: 12px">Scroll to zoom • Drag to rotate • Press <strong>C</strong> or click button for collision event</span>
    </div>
    
    <div id="detector-info">
        <strong>ATLAS Detector Layers:</strong>
        <div class="layer-info">
            <div class="layer-color" style="background: rgba(100, 255, 100, 0.85);"></div>
            <span>Inner Detector — Pixel · SCT · TRT</span>
        </div>
        <div class="layer-info">
            <div class="layer-color" style="background: rgba(0, 255, 255, 0.85);"></div>
            <span>EM Calorimeter (e<sup>±</sup>, γ shower)</span>
        </div>
        <div class="layer-info">
            <div class="layer-color" style="background: rgba(255, 165, 0, 0.85);"></div>
            <span>Hadronic Calorimeter (π, K shower)</span>
        </div>
        <div class="layer-info">
            <div class="layer-color" style="background: rgba(255, 0, 0, 0.85);"></div>
            <span>Muon Spectrometer (μ penetrates all)</span>
        </div>
        <div class="layer-info">
            <div class="layer-color" style="background: rgba(26, 58, 138, 0.95); border: 1px solid #4466cc;"></div>
            <span>Barrel Toroid Magnets (8 coils, ~1 T)</span>
        </div>
        <div class="layer-info">
            <div class="layer-color" style="background: rgba(255, 255, 0, 0.85);"></div>
            <span>MET arrow — missing E<sub>T</sub> from ν</span>
        </div>
        <br/>
        <strong>Active particles:</strong> <span id="particle-count">0</span><br/>
        <strong>Solenoid:</strong> <span id="field-strength">2</span> T &nbsp;|&nbsp; Toroid: ~1 T<br/>
        <strong>√s:</strong> 14 TeV &nbsp;|&nbsp; Depth: 100 m underground
    </div>
    
    <button id="collision-button">Trigger Collision Event</button>
    <div id="beam-status">BEAMS COLLIDING</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Global variables
        let container, stats;
        let camera, scene, renderer, controls;
        let composer, bloomPass;
        let particles = [];
        let beamParticles = [];
        let particleTraces = [];
        let detectorLayers = [];
        let magneticField = new THREE.Vector3(0, 0, 2);
        let particleGroup, traceGroup, beamGroup, showerGroup;
        let collisionInProgress = false;
        let metArrow = null;
        
        const params = {
            exposure: 5.0,
            bloomStrength: 2.5,
            bloomThreshold: 0.2,
            bloomRadius: 0.8,
            magneticFieldStrength: 2.0,
            particleCount: 0,
            traceLength: 100,
            autoRotate: false,
            showTraces: true,
            showGrid: true,
            collisionEnergy: 14,
            particleGlow: 2.0
        };

        // Particle types — each carries stopRadius (transverse r at which it is absorbed)
        // and showerType ('EM', 'HAD', or null for penetrating / invisible particles).
        // This drives the layer-accurate calorimeter-shower physics below.
        const ParticleTypes = {
            PHOTON: {
                color: 0xaaff44, charge: 0, mass: 0, name: 'Photon',
                stopRadius: 100, showerType: 'EM', emissiveIntensity: 3.0
            },
            ELECTRON: {
                color: 0x44aaff, charge: -1, mass: 0.511, name: 'Electron',
                stopRadius: 100, showerType: 'EM', emissiveIntensity: 2.5
            },
            POSITRON: {
                color: 0x44ffee, charge: 1, mass: 0.511, name: 'Positron',
                stopRadius: 100, showerType: 'EM', emissiveIntensity: 2.5
            },
            MUON: {
                // Muons are minimum-ionising — penetrate all calorimeters,
                // only stopped in / beyond the muon spectrometer (r ≈ 240)
                color: 0xcc44ff, charge: -1, mass: 105.7, name: 'Muon',
                stopRadius: 240, showerType: null, emissiveIntensity: 3.5
            },
            ANTIMUON: {
                color: 0xff88ff, charge: 1, mass: 105.7, name: 'Anti-muon',
                stopRadius: 240, showerType: null, emissiveIntensity: 3.5
            },
            PION: {
                // Charged pions are hadrons — shower in the hadronic calorimeter
                color: 0xff6600, charge: 1, mass: 139.6, name: 'Pion',
                stopRadius: 150, showerType: 'HAD', emissiveIntensity: 2.0
            },
            KAON: {
                color: 0xff9900, charge: 1, mass: 493.7, name: 'Kaon',
                stopRadius: 150, showerType: 'HAD', emissiveIntensity: 2.0
            },
            NEUTRINO: {
                // Neutrinos escape undetected — invisible, no calorimeter hit.
                // Their momentum contributes to Missing Transverse Energy (MET).
                color: 0xffff00, charge: 0, mass: 0, name: 'Neutrino',
                stopRadius: 99999, showerType: null, emissiveIntensity: 0
            }
        };

        // Beam Particle class for collision - Enhanced bloom
        class BeamParticle {
            // yOffset: vertical separation at the start position that converges
            // smoothly to zero at the interaction point (z = 0).
            // This ensures both beams are always spatially distinct — even when
            // the camera looks directly along the Z (beam) axis.
            constructor(startZ, direction, yOffset = 0) {
                this.startZ   = startZ;
                this.yOffset  = yOffset;
                this.position = new THREE.Vector3(0, yOffset, startZ);
                this.velocity = new THREE.Vector3(0, 0, direction * 50);

                // Create mesh for beam particle (proton) with enhanced bloom
                const geometry = new THREE.SphereGeometry(3, 16, 12);
                const material = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 5,
                    metalness: 0,
                    roughness: 0,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.0,
                    transparent: true,
                    opacity: 1.0,
                    depthTest: false   // always visible through any geometry
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.renderOrder = 999;
                this.mesh.position.copy(this.position);

                // Add glow sphere around beam particle
                const glowGeometry = new THREE.SphereGeometry(8, 16, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide,
                    depthTest: false   // glow always shows too
                });
                this.glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                this.glowMesh.renderOrder = 999;
                this.mesh.add(this.glowMesh);

                // Trail for beam particle
                this.trail = [];
            }

            update(deltaTime) {
                const deltaPos = this.velocity.clone().multiplyScalar(deltaTime);
                this.position.add(deltaPos);

                // Converge Y offset linearly to zero as the beam approaches z = 0.
                // At the start (|z| = 250) the full offset is applied;
                // at the collision point (z = 0) both beams meet on-axis.
                this.position.y = this.yOffset * (Math.abs(this.position.z) / Math.abs(this.startZ));

                this.mesh.position.copy(this.position);

                // Pulse the glow
                const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 1.0;
                this.glowMesh.scale.setScalar(pulse);

                // Add to trail
                this.trail.push({
                    pos: this.position.clone(),
                    opacity: 1.0
                });

                // Limit trail length
                if (this.trail.length > 20) {
                    this.trail.shift();
                }
            }
        }

        // Particle class - Enhanced bloom effects
        class Particle {
            constructor(type = null, position = null, velocity = null) {
                // Choose random particle type if not specified
                const types = Object.keys(ParticleTypes);
                const typeKey = type || types[Math.floor(Math.random() * types.length)];
                this.type = ParticleTypes[typeKey];
                
                this.position = position || new THREE.Vector3(0, 0, 0);
                
                this.velocity = velocity || new THREE.Vector3(
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30
                );
                
                this.charge = this.type.charge;
                this.mass = this.type.mass || 1;
                this.momentum = this.velocity.length() * this.mass;
                this.lifetime = 0;
                this.maxLifetime = 300;
                this.active = true;
                
                // Create mesh with enhanced bloom
                const size = this.type.name === 'Neutrino' ? 0.3 : 0.8;
                const geometry = new THREE.SphereGeometry(size, 8, 6);
                const material = new THREE.MeshPhysicalMaterial({
                    color: this.type.color,
                    emissive: this.type.color,
                    emissiveIntensity: this.type.emissiveIntensity * params.particleGlow,
                    metalness: 0.1,
                    roughness: 0.2,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.0,
                    transparent: this.type.name === 'Neutrino',
                    opacity: this.type.name === 'Neutrino' ? 0.3 : 1.0
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                
                // Add outer glow for high-energy particles
                if (this.type.emissiveIntensity > 2.0) {
                    const glowGeometry = new THREE.SphereGeometry(size * 2.5, 8, 6);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: this.type.color,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.BackSide
                    });
                    this.glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.mesh.add(this.glowMesh);
                }
                
                // Trail positions
                this.trail = [];

                // Has this particle already produced a calorimeter shower?
                this.hasShowered = false;

                // Neutrinos escape completely undetected — hide mesh entirely.
                // Their energy registers only as Missing Transverse Energy (MET).
                if (this.type.name === 'Neutrino') this.mesh.visible = false;
            }
            
            update(deltaTime) {
                if (!this.active) return;
                
                // Apply Lorentz force if charged
                if (this.charge !== 0) {
                    const lorentzForce = new THREE.Vector3().crossVectors(
                        this.velocity,
                        magneticField
                    ).multiplyScalar(this.charge * 0.01 / (this.mass || 1));
                    
                    this.velocity.add(lorentzForce);
                }
                
                // Update position
                const deltaPos = this.velocity.clone().multiplyScalar(deltaTime);
                this.position.add(deltaPos);
                this.mesh.position.copy(this.position);
                
                // Pulse glow for high-energy particles
                if (this.glowMesh) {
                    const pulse = Math.sin(Date.now() * 0.005 + this.lifetime) * 0.15 + 1.0;
                    this.glowMesh.scale.setScalar(pulse);
                }
                
                // Add to trail with enhanced glow
                if (params.showTraces) {
                    this.trail.push({
                        pos: this.position.clone(),
                        opacity: 1.0,
                        glow: this.type.emissiveIntensity > 2.0
                    });
                    
                    // Limit trail length
                    if (this.trail.length > params.traceLength) {
                        this.trail.shift();
                    }
                    
                    // Fade trail
                    this.trail.forEach((point, i) => {
                        point.opacity = (i / this.trail.length) * 0.7;
                    });
                }
                
                // Check boundaries and lifetime
                this.lifetime++;
                const distance = this.position.length();

                // Calorimeter layer physics —————————————————————————————————
                // Real ATLAS calorimeters are cylindrical, so we use the
                // *transverse* (r_xy) radius for barrel stops and |z| for end-caps.
                if (!this.hasShowered) {
                    const rTrans = Math.sqrt(
                        this.position.x * this.position.x +
                        this.position.y * this.position.y
                    );
                    const absZ = Math.abs(this.position.z);

                    // Barrel: absorbed when transverse radius exceeds stopRadius
                    // End-cap: absorbed when |z| crosses end-cap plane (215) and
                    //          particle is off-axis (not still inside beam pipe)
                    const hitBarrel = rTrans > this.type.stopRadius;
                    const hitEndCap = absZ > 215 && rTrans > 8;

                    if (hitBarrel || hitEndCap) {
                        this.hasShowered = true;
                        if (this.type.showerType) {
                            createShower(this.position.clone(), this.type.showerType);
                        }
                        this.active = false;
                        this.mesh.visible = false;
                    }
                }

                // Remove if too far out or lifetime exceeded
                if (distance > 320 || this.lifetime > this.maxLifetime) {
                    this.active = false;
                    this.mesh.visible = false;
                }
            }
        }

        // Detector Layer class
        class DetectorLayer {
            constructor(radius, name, color, segments = 24) {
                this.radius = radius;
                this.name = name;
                this.color = color;
                this.group = new THREE.Group();
                
                // Create cylindrical detector segments
                const height = 400;
                const geometry = new THREE.CylinderGeometry(
                    radius, radius, height, segments, 1, true
                );
                
                const material = new THREE.MeshPhysicalMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide,
                    metalness: 0.2,
                    roughness: 0.8,
                    clearcoat: 0.3,
                    clearcoatRoughness: 0.5
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = Math.PI / 2;
                this.group.add(mesh);
                
                // Add detector elements
                this.addDetectorElements();
            }
            
            addDetectorElements() {
                const elementGeometry = new THREE.BoxGeometry(5, 5, 20);
                const elementMaterial = new THREE.MeshPhysicalMaterial({
                    color: this.color,
                    emissive: this.color,
                    emissiveIntensity: 0.2,
                    metalness: 0.8,
                    roughness: 0.2
                });
                
                const numElements = 24;
                for (let i = 0; i < numElements; i++) {
                    const angle = (i / numElements) * Math.PI * 2;
                    const x = Math.cos(angle) * this.radius;
                    const y = Math.sin(angle) * this.radius;
                    
                    for (let z = -180; z <= 180; z += 60) {
                        const element = new THREE.Mesh(elementGeometry, elementMaterial);
                        element.position.set(x, y, z);
                        element.lookAt(0, 0, z);
                        this.group.add(element);
                    }
                }
            }
        }

        init();
        animate();

        function init() {
            container = document.getElementById('container');

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                60, window.innerWidth / window.innerHeight, 0.1, 5000
            );
            camera.position.set(300, 200, 300);

            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 200, 1000);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = params.exposure;
            container.appendChild(renderer.domElement);

            // Post-processing with enhanced bloom
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                params.bloomStrength,
                params.bloomRadius,
                params.bloomThreshold
            );
            composer.addPass(bloomPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 50;
            controls.maxDistance = 1000;
            controls.autoRotate = params.autoRotate;
            controls.autoRotateSpeed = 0.5;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -250;
            directionalLight.shadow.camera.right = 250;
            directionalLight.shadow.camera.top = 250;
            directionalLight.shadow.camera.bottom = -250;
            scene.add(directionalLight);

            // Point lights for dramatic effect
            const pointLight1 = new THREE.PointLight(0x00ffff, 2, 300);
            pointLight1.position.set(0, 0, 0);
            scene.add(pointLight1);

            // Create detector layers
            createDetectorLayers();

            // Create particle systems
            particleGroup = new THREE.Group();
            scene.add(particleGroup);
            
            traceGroup = new THREE.Group();
            scene.add(traceGroup);
            
            beamGroup = new THREE.Group();
            scene.add(beamGroup);

            showerGroup = new THREE.Group();
            scene.add(showerGroup);

            // Add beam pipes (visual representation)
            createBeamPipes();

            // Outer detector casing — bottom semi-cylinder, open top
            createOuterCasing();

            // 8-coil barrel toroid magnets
            createBarrelToroids();

            // End-cap detector discs (forward region coverage)
            createEndCaps();

            // Grid helper
            const gridHelper = new THREE.GridHelper(400, 40, 0x444444, 0x222222);
            gridHelper.position.y = -200;
            scene.add(gridHelper);

            // Axis helper
            const axesHelper = new THREE.AxesHelper(100);
            scene.add(axesHelper);

            // Stats
            stats = new Stats();
            container.appendChild(stats.dom);

            // GUI
            setupGUI();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keypress', onKeyPress);
            
            document.getElementById('collision-button').addEventListener('click', () => {
                if (!collisionInProgress) {
                    triggerCollision();
                }
            });

            updateParticleCount();
        }

        function createBeamPipes() {
            const pipeGeometry = new THREE.CylinderGeometry(5, 5, 500, 16);
            const pipeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x333333,
                metalness: 0.9,
                roughness: 0.3,
                transparent: true,
                opacity: 0.3
            });

            const beamPipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
            beamPipe.rotation.x = Math.PI / 2;
            scene.add(beamPipe);
        }

        function createOuterCasing() {
            const casingRadius = 228;   // just outside Muon Spectrometer (r = 200)
            const casingLength = 450;

            // ── Main shell material ─────────────────────────────────────────
            // Dark steel with subtle blue tint; transparent so inner layers are visible
            const shellMat = new THREE.MeshPhysicalMaterial({
                color: 0x1a1e2e,
                metalness: 0.92,
                roughness: 0.38,
                transparent: true,
                opacity: 0.78,
                side: THREE.DoubleSide,
                depthWrite: false,
                emissive: 0x05080f,
                emissiveIntensity: 0.5
            });

            // ── Bottom semi-cylinder shell ──────────────────────────────────
            // CylinderGeometry theta [0 → PI], then rotation.x = PI/2
            //   maps that arc to the world Y ≤ 0 (bottom) half of the barrel
            const shellGeom = new THREE.CylinderGeometry(
                casingRadius, casingRadius, casingLength,
                80, 1, true,    // openEnded = true (no caps on the cylinder itself)
                0, Math.PI      // half arc
            );
            const shellMesh = new THREE.Mesh(shellGeom, shellMat);
            shellMesh.rotation.x = Math.PI / 2;
            shellMesh.renderOrder = 1;
            scene.add(shellMesh);

            // ── Semi-circular end caps (with beam-pipe hole) ────────────────
            // RingGeometry lies in the XY plane.
            // thetaStart = PI, thetaLength = PI  →  arc from -X through -Y to +X
            //   = the Y < 0 (bottom) semicircle, matching the shell above
            const capGeom = new THREE.RingGeometry(9, casingRadius, 80, 1, Math.PI, Math.PI);
            const capMat = shellMat.clone();

            const cap1 = new THREE.Mesh(capGeom, capMat);
            cap1.position.z = casingLength / 2;
            cap1.renderOrder = 1;
            scene.add(cap1);

            const cap2 = new THREE.Mesh(capGeom, capMat);
            cap2.position.z = -casingLength / 2;
            cap2.renderOrder = 1;
            scene.add(cap2);

            // ── Opening-edge lip rails ──────────────────────────────────────
            // Two metal strips running the full length at x = ±casingRadius, y = 0.
            // These define the hard edge where the casing stops and the open top begins.
            // High emissive so they catch the bloom and look like powered rails.
            const lipMat = new THREE.MeshPhysicalMaterial({
                color: 0x3a3f5c,
                metalness: 0.96,
                roughness: 0.08,
                emissive: 0x10183a,
                emissiveIntensity: 1.4
            });
            const lipGeom = new THREE.BoxGeometry(6, 6, casingLength);
            [-casingRadius, casingRadius].forEach(x => {
                const lip = new THREE.Mesh(lipGeom, lipMat);
                lip.position.set(x, 0, 0);
                scene.add(lip);
            });

            // ── Circumferential structural ribs ────────────────────────────
            // Half-torus rings sit flush on the outside of the shell at regular
            // intervals, giving the detector the look of a real cryostat / yoke.
            // TorusGeometry arc = PI creates the top-half arch by default;
            // rotation.x = PI flips it to the bottom half (Y < 0).
            const ribMat = new THREE.MeshPhysicalMaterial({
                color: 0x252840,
                metalness: 0.88,
                roughness: 0.25,
                emissive: 0x080a12,
                emissiveIntensity: 0.3
            });
            [-180, -90, 0, 90, 180].forEach(zPos => {
                const ribGeom = new THREE.TorusGeometry(
                    casingRadius + 3, 5, 12, 80, Math.PI
                );
                const rib = new THREE.Mesh(ribGeom, ribMat);
                rib.rotation.x = Math.PI;   // flip arch to Y ≤ 0 (bottom) half
                rib.position.z = zPos;
                scene.add(rib);
            });
        }

        // ── Calorimeter shower visualisation ─────────────────────────────────
        // Creates a brief burst of glowing particles at the point where a
        // primary particle is absorbed by a calorimeter layer.
        // EM showers (e±, γ) are compact and yellow-green.
        // Hadronic showers (π, K) are wider and orange-red.
        function createShower(position, showerType) {
            const isEM = showerType === 'EM';
            const count     = isEM ? 10 : 16;
            const maxSpread = isEM ? 12 : 22;
            const color     = isEM ? 0xffee44 : 0xff5500;
            const lightCol  = isEM ? 0xffff88 : 0xff8844;
            const initInt   = isEM ? 10 : 6;

            // Transient point-light flash at the shower vertex
            const light = new THREE.PointLight(lightCol, initInt, 90);
            light.position.copy(position);
            scene.add(light);
            let lt = 0;
            const decayLight = () => {
                lt += 0.07;
                light.intensity = Math.max(0, initInt * (1 - lt));
                if (lt < 1) requestAnimationFrame(decayLight);
                else scene.remove(light);
            };
            decayLight();

            // Spray particles outward from impact point
            for (let i = 0; i < count; i++) {
                const mat  = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1.0 });
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.55, 4, 4), mat);
                mesh.position.copy(position);

                // Direction: radially outward from collision axis + cone spread
                const spread = isEM ? 0.5 : 1.1;
                const dir = position.clone().normalize()
                    .add(new THREE.Vector3(
                        (Math.random() - 0.5) * spread,
                        (Math.random() - 0.5) * spread,
                        (Math.random() - 0.5) * spread
                    )).normalize()
                    .multiplyScalar(maxSpread * (0.4 + Math.random() * 0.6));

                scene.add(mesh);
                let t = 0;
                const spd = isEM ? 0.065 : 0.042;
                const tick = () => {
                    t += spd;
                    mesh.position.addScaledVector(dir, spd * 1.6);
                    mat.opacity = Math.max(0, 1 - t);
                    mesh.scale.setScalar(1 + t * 2.5);
                    if (t < 1) requestAnimationFrame(tick);
                    else scene.remove(mesh);
                };
                tick();
            }
        }

        // ── Missing Transverse Energy (MET) arrow ────────────────────────────
        // Neutrinos carry momentum that is never detected. The vector sum of
        // their transverse momenta appears as a yellow arrow pointing in the
        // direction of "missing" energy — a key dark-matter search signature.
        function showMETArrow(metX, metY) {
            if (metArrow) { scene.remove(metArrow); metArrow = null; }
            const mag = Math.sqrt(metX * metX + metY * metY);
            if (mag < 3) return;
            const dir    = new THREE.Vector3(metX, metY, 0).normalize();
            const length = Math.min(mag * 4, 175);
            metArrow = new THREE.ArrowHelper(
                dir, new THREE.Vector3(0, 0, 0), length,
                0xffff00, 18, 10
            );
            scene.add(metArrow);
            // Auto-fade after 4 s
            setTimeout(() => { if (metArrow) { scene.remove(metArrow); metArrow = null; } }, 4000);
        }

        // ── ATLAS Barrel Toroid Magnets ──────────────────────────────────────
        // The barrel toroid is the most visually iconic part of ATLAS:
        // 8 air-core superconducting coils arranged in an octagon around the
        // beam axis, each coil lying in a plane that contains the Z-axis.
        // They produce the ~1 T azimuthal field that bends muons in the R-Z plane.
        function createBarrelToroids() {
            const nCoils = 8;
            const rInner = 165, rOuter = 210;   // coil radial extent
            const zEnd   = 182;                  // coil half-length along Z
            const barW   = 6,  barH = 6;         // cross-section of coil bar
            const radLen = rOuter - rInner;       // 45 — length of radial bars
            const midR   = (rInner + rOuter) / 2; // 187.5 — centre of radial bars
            const zLen   = zEnd * 2;              // 364 — length of longitudinal bars

            const coilMat = new THREE.MeshPhysicalMaterial({
                color: 0x1a3a8a,
                metalness: 0.92,
                roughness: 0.18,
                emissive: 0x061228,
                emissiveIntensity: 0.9
            });

            for (let i = 0; i < nCoils; i++) {
                const angle = (i / nCoils) * Math.PI * 2;
                const cos   = Math.cos(angle);
                const sin   = Math.sin(angle);

                // Each coil is a rectangular frame built from 4 box-bars.
                // rotation.z = angle aligns the bar's X axis radially at angle θ.

                // Top radial bar  (z = +zEnd)
                const topBar = new THREE.Mesh(new THREE.BoxGeometry(radLen, barH, barW), coilMat);
                topBar.position.set(midR * cos, midR * sin, zEnd);
                topBar.rotation.z = angle;
                scene.add(topBar);

                // Bottom radial bar  (z = -zEnd)
                const botBar = new THREE.Mesh(new THREE.BoxGeometry(radLen, barH, barW), coilMat);
                botBar.position.set(midR * cos, midR * sin, -zEnd);
                botBar.rotation.z = angle;
                scene.add(botBar);

                // Inner longitudinal bar  (r = rInner, runs full length in Z)
                const innerBar = new THREE.Mesh(new THREE.BoxGeometry(barW, barH, zLen), coilMat);
                innerBar.position.set(rInner * cos, rInner * sin, 0);
                innerBar.rotation.z = angle;
                scene.add(innerBar);

                // Outer longitudinal bar  (r = rOuter)
                const outerBar = new THREE.Mesh(new THREE.BoxGeometry(barW, barH, zLen), coilMat);
                outerBar.position.set(rOuter * cos, rOuter * sin, 0);
                outerBar.rotation.z = angle;
                scene.add(outerBar);

                // Corner joints — small cubes where bars meet
                const cGeom = new THREE.BoxGeometry(barW + 3, barH + 3, barW + 3);
                [[rInner, zEnd], [rOuter, zEnd], [rInner, -zEnd], [rOuter, -zEnd]]
                    .forEach(([r, z]) => {
                        const corner = new THREE.Mesh(cGeom, coilMat);
                        corner.position.set(r * cos, r * sin, z);
                        scene.add(corner);
                    });
            }
        }

        // ── End-cap detector discs ────────────────────────────────────────────
        // ATLAS has two end-caps (at each end of the barrel) that extend
        // detector coverage toward the forward region (high pseudorapidity η).
        // Each end-cap is a set of concentric ring-shaped detector layers.
        function createEndCaps() {
            const endCapZs = [220, -220];

            // Layer definitions — concentric rings matching the barrel colours
            const layers = [
                { rIn:  5, rOut:  50, color: 0x64ff64, label: 'ID' },
                { rIn: 50, rOut: 100, color: 0x00ffff, label: 'EM Cal' },
                { rIn:100, rOut: 150, color: 0xffa500, label: 'Had Cal' },
                { rIn:150, rOut: 208, color: 0xff0000, label: 'Muon' }
            ];

            endCapZs.forEach(z => {
                layers.forEach(layer => {
                    // Translucent ring face
                    const ringMat = new THREE.MeshPhysicalMaterial({
                        color: layer.color,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide,
                        metalness: 0.2,
                        roughness: 0.8,
                        emissive: layer.color,
                        emissiveIntensity: 0.04
                    });
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(layer.rIn, layer.rOut, 48, 1),
                        ringMat
                    );
                    ring.position.z = z;
                    scene.add(ring);

                    // Segmented detector modules arranged in a ring —
                    // mimics the real module/sector granularity of each sub-detector
                    const nSegs = 24;
                    const midR  = (layer.rIn + layer.rOut) / 2;
                    const segW  = (layer.rOut - layer.rIn) * 0.78;
                    const segD  = 8;
                    const segMat = new THREE.MeshPhysicalMaterial({
                        color: layer.color,
                        emissive: layer.color,
                        emissiveIntensity: 0.28,
                        metalness: 0.8,
                        roughness: 0.2
                    });

                    for (let i = 0; i < nSegs; i++) {
                        const phi = (i / nSegs) * Math.PI * 2;
                        const seg = new THREE.Mesh(
                            new THREE.BoxGeometry(segW, 4, segD),
                            segMat
                        );
                        seg.position.set(
                            midR * Math.cos(phi),
                            midR * Math.sin(phi),
                            z + Math.sign(z) * segD * 0.5
                        );
                        seg.rotation.z = phi; // align radially
                        scene.add(seg);
                    }
                });
            });
        }

        function createDetectorLayers() {
            // Inner Detector
            const innerDetector = new DetectorLayer(50, 'Inner Detector', 0x64ff64);
            scene.add(innerDetector.group);
            detectorLayers.push(innerDetector);

            // EM Calorimeter
            const emCalorimeter = new DetectorLayer(100, 'EM Calorimeter', 0x00ffff);
            scene.add(emCalorimeter.group);
            detectorLayers.push(emCalorimeter);

            // Hadronic Calorimeter
            const hadronicCalorimeter = new DetectorLayer(150, 'Hadronic Calorimeter', 0xffa500);
            scene.add(hadronicCalorimeter.group);
            detectorLayers.push(hadronicCalorimeter);

            // Muon Spectrometer
            const muonSpectrometer = new DetectorLayer(200, 'Muon Spectrometer', 0xff0000);
            scene.add(muonSpectrometer.group);
            detectorLayers.push(muonSpectrometer);
        }

        function triggerCollision() {
            collisionInProgress = true;
            document.getElementById('collision-button').disabled = true;
            document.getElementById('beam-status').style.display = 'block';
            
            // Clear existing particles
            particles.forEach(p => {
                if (p.mesh) particleGroup.remove(p.mesh);
            });
            particles = [];
            
            // Create two beam particles coming from opposite sides.
            // +6 / -6 Y offset at the start ensures they are always spatially
            // distinct even when viewed end-on along the beam (Z) axis.
            // Both offsets converge to y = 0 exactly at the collision point.
            const beam1 = new BeamParticle(-250,  1, +6);
            const beam2 = new BeamParticle( 250, -1, -6);
            
            beamParticles = [beam1, beam2];
            beamGroup.add(beam1.mesh);
            beamGroup.add(beam2.mesh);
            
            // Animate beam collision
            const collisionTime = 2500; // 2.5 seconds to collision
            const startTime = Date.now();
            
            const animateBeams = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / collisionTime;
                
                if (progress < 1) {
                    // Move beams toward center
                    beamParticles.forEach(beam => {
                        beam.update(0.016);
                    });
                    
                    requestAnimationFrame(animateBeams);
                } else {
                    // Collision happens!
                    executeCollision();
                }
            };
            
            animateBeams();
        }

        function executeCollision() {
            // Remove beam particles
            beamParticles.forEach(beam => {
                beamGroup.remove(beam.mesh);
            });
            beamParticles = [];

            // Clear previous MET arrow if still visible
            if (metArrow) { scene.remove(metArrow); metArrow = null; }

            // Create explosion at center
            createCollisionExplosion();
            
            // Generate collision products based on physics
            generateCollisionProducts();
            
            // Reset UI
            setTimeout(() => {
                document.getElementById('collision-button').disabled = false;
                document.getElementById('beam-status').style.display = 'none';
                collisionInProgress = false;
            }, 1000);
            
            updateParticleCount();
        }

        function createCollisionExplosion() {
            // Create bright flash at collision point with enhanced bloom
            const flash = new THREE.PointLight(0xffffff, 30, 500);
            flash.position.set(0, 0, 0);
            scene.add(flash);
            
            // Create expanding sphere effect with bloom
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 10,
                transparent: true,
                opacity: 1,
                side: THREE.BackSide
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);
            
            // Create secondary shockwave
            const shockwaveGeometry = new THREE.RingGeometry(1, 2, 64);
            const shockwaveMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 5,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.rotation.x = Math.PI / 2;
            scene.add(shockwave);
            
            // Animate explosion
            const animateExplosion = () => {
                flash.intensity *= 0.92;
                sphere.scale.multiplyScalar(1.15);
                sphereMaterial.opacity *= 0.95;
                sphereMaterial.emissiveIntensity *= 0.95;
                
                shockwave.scale.multiplyScalar(1.2);
                shockwaveMaterial.opacity *= 0.93;
                shockwaveMaterial.emissiveIntensity *= 0.93;
                
                if (flash.intensity > 0.01) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(flash);
                    scene.remove(sphere);
                    scene.remove(shockwave);
                }
            };
            
            animateExplosion();
        }

        function generateCollisionProducts() {
            // Generate particles based on realistic collision physics
            const particleCount = 30 + Math.floor(Math.random() * 20);

            // Accumulate neutrino transverse momenta → Missing Transverse Energy
            let metX = 0, metY = 0;

            for (let i = 0; i < particleCount; i++) {
                let type;
                const rand = Math.random();
                
                // Particle type distribution (roughly based on real LHC data)
                if (rand < 0.4) {
                    // 40% pions/kaons (hadrons)
                    type = Math.random() > 0.5 ? 'PION' : 'KAON';
                } else if (rand < 0.6) {
                    // 20% photons
                    type = 'PHOTON';
                } else if (rand < 0.75) {
                    // 15% electrons/positrons
                    type = Math.random() > 0.5 ? 'ELECTRON' : 'POSITRON';
                } else if (rand < 0.9) {
                    // 15% muons
                    type = Math.random() > 0.5 ? 'MUON' : 'ANTIMUON';
                } else {
                    // 10% neutrinos (invisible)
                    type = 'NEUTRINO';
                }
                
                // Generate velocity with momentum conservation consideration
                const theta = Math.random() * Math.PI; // Polar angle
                const phi = Math.random() * Math.PI * 2; // Azimuthal angle
                const momentum = 10 + Math.random() * 40; // Variable momentum
                
                const velocity = new THREE.Vector3(
                    momentum * Math.sin(theta) * Math.cos(phi),
                    momentum * Math.sin(theta) * Math.sin(phi),
                    momentum * Math.cos(theta)
                );
                
                // Add some transverse momentum bias (jets)
                if (Math.random() < 0.3) {
                    velocity.multiplyScalar(1.5);
                }
                
                const particle = new Particle(
                    type,
                    new THREE.Vector3(0, 0, 0), // Start at collision point
                    velocity
                );

                // Neutrinos contribute only to MET — never seen in detector
                if (type === 'NEUTRINO') {
                    metX += velocity.x;
                    metY += velocity.y;
                }

                particles.push(particle);
                particleGroup.add(particle.mesh);
            }

            // Show MET arrow after all particles generated
            showMETArrow(metX, metY);
            
            // Create back-to-back jets (common in high-energy collisions)
            if (Math.random() < 0.7) {
                const jetDirection = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    0
                ).normalize();
                
                // Jet 1
                for (let i = 0; i < 5; i++) {
                    const velocity = jetDirection.clone()
                        .multiplyScalar(30 + Math.random() * 20)
                        .add(new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        ));
                    
                    const particle = new Particle(
                        Math.random() > 0.5 ? 'PION' : 'KAON',
                        new THREE.Vector3(0, 0, 0),
                        velocity
                    );
                    
                    particles.push(particle);
                    particleGroup.add(particle.mesh);
                }
                
                // Jet 2 (opposite direction)
                for (let i = 0; i < 5; i++) {
                    const velocity = jetDirection.clone()
                        .multiplyScalar(-30 - Math.random() * 20)
                        .add(new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        ));
                    
                    const particle = new Particle(
                        Math.random() > 0.5 ? 'PION' : 'KAON',
                        new THREE.Vector3(0, 0, 0),
                        velocity
                    );
                    
                    particles.push(particle);
                    particleGroup.add(particle.mesh);
                }
            }
        }

        function setupGUI() {
            const gui = new GUI();

            const renderFolder = gui.addFolder('Rendering');
            renderFolder.add(params, 'exposure', 0, 10).onChange(value => {
                renderer.toneMappingExposure = value;
            });
            renderFolder.add(params, 'bloomStrength', 0, 5).onChange(value => {
                bloomPass.strength = value;
            });
            renderFolder.add(params, 'bloomThreshold', 0, 1).onChange(value => {
                bloomPass.threshold = value;
            });
            renderFolder.add(params, 'bloomRadius', 0, 2).onChange(value => {
                bloomPass.radius = value;
            });
            renderFolder.add(params, 'particleGlow', 0.5, 5).onChange(value => {
                // Update existing particles glow
                particles.forEach(particle => {
                    if (particle.mesh && particle.mesh.material) {
                        particle.mesh.material.emissiveIntensity = particle.type.emissiveIntensity * value;
                    }
                });
            });

            const physicsFolder = gui.addFolder('Physics');
            physicsFolder.add(params, 'magneticFieldStrength', 0, 5).onChange(value => {
                magneticField.z = value;
                document.getElementById('field-strength').textContent = value.toFixed(1);
            });
            physicsFolder.add(params, 'collisionEnergy', 7, 14).name('Collision Energy (TeV)');

            const displayFolder = gui.addFolder('Display');
            displayFolder.add(params, 'showTraces');
            displayFolder.add(params, 'traceLength', 10, 200, 1);
            displayFolder.add(params, 'autoRotate').onChange(value => {
                controls.autoRotate = value;
            });
            displayFolder.add(params, 'showGrid').onChange(value => {
                const grid = scene.getObjectByName('GridHelper');
                if (grid) grid.visible = value;
            });

            gui.open();
        }

        function updateParticleCount() {
            const activeParticles = particles.filter(p => p.active).length;
            document.getElementById('particle-count').textContent = activeParticles;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyPress(event) {
            if ((event.key === 'c' || event.key === 'C') && !collisionInProgress) {
                triggerCollision();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = 0.016; // ~60fps
            
            // Update particles
            particles.forEach(particle => {
                particle.update(deltaTime);
            });
            
            // Remove inactive particles periodically
            if (Math.random() < 0.01) {
                const activeParticles = particles.filter(p => p.active);
                if (activeParticles.length !== particles.length) {
                    particles.forEach(p => {
                        if (!p.active && p.mesh) {
                            particleGroup.remove(p.mesh);
                        }
                    });
                    particles = activeParticles;
                    updateParticleCount();
                }
            }
            
            // Update traces with enhanced glow
            if (params.showTraces) {
                updateTraces();
            }
            
            // Update controls
            controls.update();
            
            // Render
            composer.render();
            stats.update();
        }

        function updateTraces() {
            // Clear existing trace geometry
            traceGroup.clear();
            
            // Draw traces for active particles with enhanced glow
            particles.forEach(particle => {
                if (particle.trail.length > 1 && particle.active) {
                    const points = particle.trail.map(t => t.pos);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    // Enhanced trail material with glow
                    const material = new THREE.LineBasicMaterial({
                        color: particle.type.color,
                        transparent: true,
                        opacity: particle.type.name === 'Neutrino' ? 0.2 : 0.7,
                        linewidth: particle.trail[0].glow ? 2 : 1
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    traceGroup.add(line);
                }
            });
            
            // Draw beam traces with enhanced glow
            beamParticles.forEach(beam => {
                if (beam.trail.length > 1) {
                    const points = beam.trail.map(t => t.pos);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    const material = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 1.0,
                        linewidth: 3
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    traceGroup.add(line);
                }
            });
        }
    </script>
</body>
</html>
